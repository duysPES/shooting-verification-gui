<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pysrc.gui API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysrc.gui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import PySimpleGUI as sg
from pysrc.config import Config
from pysrc.layout import LayOuts
import serial
from pysrc.lisc import LISC
from pysrc.switch_sim import SimClient, Simulator
from pysrc.states_sim import SimStates, SimStateMachine
from multiprocessing import Process, Queue
import time
from pysrc.thread import InfoType, ConnMode
from collections import deque
from pysrc.switch import Switch
from pysrc.commands import Status, Commands
import pysrc.log as log

c = Config()

sg.change_look_and_feel(&#39;GreenTan&#39;)

log.Log.clear()


class SSI:
    &#34;&#34;&#34;
    Main Program handler. Controls GUI that users will be using
    to inventory addressable switches, and running switch simulator
    &#34;&#34;&#34;

    lo = LayOuts()
    &#34;&#34;&#34;
    variable to helper class that stores all layouts for PySimpleGui
    &#34;&#34;&#34;

    inventory_queue = Queue()
    &#34;&#34;&#34;
    thread-safe *half-duplex* channel that is used when moving
    entire inventory process on a seperate thread. This allows for communication
    back to main thread.
    &#34;&#34;&#34;
    def __init__(self):
        self.layout = self.lo.main_layout()
        self.window = sg.Window(&#34;&#34;,
                                layout=self.layout,
                                default_element_size=(40, 1),
                                grab_anywhere=False,
                                size=(str(c.ssi(&#34;width&#34;)),
                                      str(c.ssi(&#34;height&#34;))),
                                finalize=True)
        self.set_window_title()

    @staticmethod
    def log(msg, status=&#39;info&#39;):
        &#34;&#34;&#34;
        ```python
        input: str
        return: None
        ```
        Wrapper around log object to verify that output from GUI is going to gui.log
        &#34;&#34;&#34;
        log.log(status)(msg, log.LogType.gui)

    def send_to_multiline(self, widget, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: sg.Element, str, bool
        return: None
        ```
        helper method to update a tk multiline element

        ```python
        my_widget = window[&#39;label&#39;]
        send_to_multiline(my_widget, msg=&#34;hello, world&#34;, clear=False)

        print(my_widget.DisplayText) # &#34;hello, world&#34;
        ```
        &#34;&#34;&#34;

        if clear:
            widget(msg)
        else:
            current = widget.get()
            new_string = current + str(msg)
            widget(new_string)

    def write_element(self, window, key, msg, append=True):
        &#34;&#34;&#34;
        ```
        input: sg.Window, str, str, bool
        return: None
        ```
        same functionality as send_to_multiline except you can 
        specifiy sg.Window object.

        &#34;&#34;&#34;

        ele = window.Element(key)
        try:
            ele.update(msg + &#39;\n&#39;, append=append)
        except Exception:
            ele.DisplayText = msg

    def send_to_main(self, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: str, bool
        return: None
        ```
        helper method to update main multiline element in 
        GUI, where Switch information is posted.
        &#34;&#34;&#34;
        widget = self.window[&#39;multiline_switch_canvas&#39;]
        self.send_to_multiline(widget=widget, msg=msg, clear=clear)

    def send_to_debug(self, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: str, bool
        return: None
        ```
        helper method to update multiline that serves as debug output.

        &#34;&#34;&#34;
        widget = self.window[&#39;multiline_default_output&#39;]
        self.send_to_multiline(widget=widget, msg=msg, clear=clear)

    def update_anticipated(self, num):
        &#34;&#34;&#34;        
        ```
        input: str
        return: None
        ```
        helper method to update number of anticipated switches

        &#34;&#34;&#34;
        w = self.window[&#39;label_anticipated_amount&#39;]
        w(num)

    def set_window_title(self, msg=&#34;&#34;):
        &#34;&#34;&#34;
        ```
        input: str
        return: None
        ```
        Set window title.

        &#34;&#34;&#34;
        msg = &#34;SSI v{} {}&#34;.format(c.ssi(&#34;version&#34;), msg)
        self.window.TKroot.title(msg)

    def loop(self):
        &#34;&#34;&#34;
        **main program loop, this is where ALL 
        the magic happens.**

        ```python
        gui.loop()
        # things crash
        # things burn
        # things take over the world.
        ```
        &#34;&#34;&#34;

        inventory = False

        while True:
            event, values = self.window.read(timeout=c.ssi(&#39;async_timeout&#39;))
            if event != &#39;__TIMEOUT__&#39;:
                pass
            if event in (None, &#39;Quit&#39;):
                break

            if &#39;Change Expected Amount&#39; in event:
                cur_val = self.window[&#39;label_expected_amount&#39;].DisplayText
                layout = [[
                    sg.Input(&#34;{}&#34;.format(cur_val), focus=True, key=&#39;input_box&#39;)
                ], [sg.Button(&#39;Exit&#39;, bind_return_key=True)]]
                win2 = sg.Window(&#34;Edit Expected Amount&#34;, layout=layout)

                while True:
                    ev2, vals2 = win2.read()
                    if ev2 is None or ev2 == &#39;Exit&#39;:

                        self.window[&#39;label_expected_amount&#39;](str(
                            vals2[&#39;input_box&#39;]))
                        win2.close()
                        break

            if &#39;Run&#39; == values[&#39;main_menu&#39;]:
                self.log(&#39;Beginning simulation&#39;, &#39;info&#39;)
                simulator = Simulator(self)
                simulator.run()

            if &#39;button_inventory&#39; in event:
                self.log(&#34;Beginning inventory run&#34;, &#39;info&#39;)
                inventory = True
                self.set_window_title()

                expected_switches = self.read_expected()
                self.send_to_debug(f&#34;Expecting {expected_switches} switches..&#34;)

                port = str(c.lisc(&#39;port&#39;))
                baudrate = int(c.lisc(&#39;baudrate&#39;))
                with LISC(port=port, baudrate=baudrate, timeout=0) as lisc:
                    self.log(&#34;Spawning thread for inventory run&#34;, &#39;info&#39;)
                    thread = Process(target=lisc.do_inventory,
                                     args=(self.inventory_queue,
                                           expected_switches))
                    thread.start()

            if inventory:
                try:
                    # returns a deque object with information
                    msgs = self.inventory_queue.get_nowait()
                    if not isinstance(msgs, deque):
                        &#34;&#34;&#34;
                        This piece of code should never run, if it does it is a programmer induced bug
                        and not the users fault. msgs is in incorrect format, the entire program will
                        not work as intended. Instead of exiting the programming, simply stop the inventory
                        process and default back to normal GUI.
                        &#34;&#34;&#34;
                        inventory = False  # turn off inventory
                        errmsg = \
                        &#34;&#34;&#34;
                        Message from queue is not a ConnPackage, fatal error. Program will
                        not work as expected
                        &#34;&#34;&#34;
                        self.log(errmsg, &#39;error&#39;)

                    if len(msgs) &gt; 0:

                        info_type, mode, msg = msgs
                        if info_type == InfoType.KILL:
                            msg = &#34;Done with inventory process&#34;
                            self.send_mode(mode, msg)
                            inventory = False
                            self.log(msg, &#34;info&#34;)

                        if info_type == InfoType.SWITCH:

                            if mode == ConnMode.STATUS:
                                pos, addr, status = msg
                                self.send_mode(mode, status)

                            if mode == ConnMode.MAIN:
                                pos, addr = msg
                                self.update_anticipated(num=int(pos))
                                msg = &#34;--&gt; {}: [{}]&#34;.format(pos, addr)
                                self.send_mode(mode, msg)

                        if info_type == InfoType.OTHER:
                            self.send_mode(mode, msg)

                except Exception:
                    pass

        self.window.close()
        self.log(&#34;Main Gui loop closing&#34;, &#34;info&#34;)

    def read_expected(self):
        &#34;&#34;&#34;
        ```python
        input: None
        return: int
        ```
        Helper method that returns the number for anticipated switches
        from label. Attempts to convert to int, with some error checking.
        If it fails the conversion it will by default return `1`
        &#34;&#34;&#34;
        num = self.window[&#39;label_expected_amount&#39;].DisplayText
        try:
            num = int(num)
        except ValueError:
            num = 1

        return num

    def send_mode(self, mode, payload):
        &#34;&#34;&#34;
        ```
        input: ConnMode, PyObj
        return: None
        ```

        a proxy method that takes incoming data from 
        the queue object, and updates applicable elements
        within the main gui based on Connection Mode and InfoTypes
        found in packets.
        &#34;&#34;&#34;
        print(&#39;mode&#39;, mode)
        if mode == ConnMode.DEBUG:
            self.send_to_debug(msg=payload, clear=False)
        elif mode == ConnMode.MAIN:
            self.send_to_main(msg=payload, clear=False)

        elif mode == ConnMode.STATUS:
            status = Status(status)
            voltage = status.voltage
            temp = status.temp

            msg = &#34;{}V, {}C&#34;.format(voltage, temp)
            self.set_window_title(msg=msg)
        else:
            errmsg = \
                &#34;&#34;&#34;
                This block should never run. Input ConnMode from 
                thread supplies an invalid enum type, mode: {}
                &#34;&#34;&#34;.format(mode)
            self.log(errmsg, &#39;error&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pysrc.gui.SSI"><code class="flex name class">
<span>class <span class="ident">SSI</span></span>
</code></dt>
<dd>
<section class="desc"><p>Main Program handler. Controls GUI that users will be using
to inventory addressable switches, and running switch simulator</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSI:
    &#34;&#34;&#34;
    Main Program handler. Controls GUI that users will be using
    to inventory addressable switches, and running switch simulator
    &#34;&#34;&#34;

    lo = LayOuts()
    &#34;&#34;&#34;
    variable to helper class that stores all layouts for PySimpleGui
    &#34;&#34;&#34;

    inventory_queue = Queue()
    &#34;&#34;&#34;
    thread-safe *half-duplex* channel that is used when moving
    entire inventory process on a seperate thread. This allows for communication
    back to main thread.
    &#34;&#34;&#34;
    def __init__(self):
        self.layout = self.lo.main_layout()
        self.window = sg.Window(&#34;&#34;,
                                layout=self.layout,
                                default_element_size=(40, 1),
                                grab_anywhere=False,
                                size=(str(c.ssi(&#34;width&#34;)),
                                      str(c.ssi(&#34;height&#34;))),
                                finalize=True)
        self.set_window_title()

    @staticmethod
    def log(msg, status=&#39;info&#39;):
        &#34;&#34;&#34;
        ```python
        input: str
        return: None
        ```
        Wrapper around log object to verify that output from GUI is going to gui.log
        &#34;&#34;&#34;
        log.log(status)(msg, log.LogType.gui)

    def send_to_multiline(self, widget, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: sg.Element, str, bool
        return: None
        ```
        helper method to update a tk multiline element

        ```python
        my_widget = window[&#39;label&#39;]
        send_to_multiline(my_widget, msg=&#34;hello, world&#34;, clear=False)

        print(my_widget.DisplayText) # &#34;hello, world&#34;
        ```
        &#34;&#34;&#34;

        if clear:
            widget(msg)
        else:
            current = widget.get()
            new_string = current + str(msg)
            widget(new_string)

    def write_element(self, window, key, msg, append=True):
        &#34;&#34;&#34;
        ```
        input: sg.Window, str, str, bool
        return: None
        ```
        same functionality as send_to_multiline except you can 
        specifiy sg.Window object.

        &#34;&#34;&#34;

        ele = window.Element(key)
        try:
            ele.update(msg + &#39;\n&#39;, append=append)
        except Exception:
            ele.DisplayText = msg

    def send_to_main(self, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: str, bool
        return: None
        ```
        helper method to update main multiline element in 
        GUI, where Switch information is posted.
        &#34;&#34;&#34;
        widget = self.window[&#39;multiline_switch_canvas&#39;]
        self.send_to_multiline(widget=widget, msg=msg, clear=clear)

    def send_to_debug(self, msg, clear=False):
        &#34;&#34;&#34;
        ```
        input: str, bool
        return: None
        ```
        helper method to update multiline that serves as debug output.

        &#34;&#34;&#34;
        widget = self.window[&#39;multiline_default_output&#39;]
        self.send_to_multiline(widget=widget, msg=msg, clear=clear)

    def update_anticipated(self, num):
        &#34;&#34;&#34;        
        ```
        input: str
        return: None
        ```
        helper method to update number of anticipated switches

        &#34;&#34;&#34;
        w = self.window[&#39;label_anticipated_amount&#39;]
        w(num)

    def set_window_title(self, msg=&#34;&#34;):
        &#34;&#34;&#34;
        ```
        input: str
        return: None
        ```
        Set window title.

        &#34;&#34;&#34;
        msg = &#34;SSI v{} {}&#34;.format(c.ssi(&#34;version&#34;), msg)
        self.window.TKroot.title(msg)

    def loop(self):
        &#34;&#34;&#34;
        **main program loop, this is where ALL 
        the magic happens.**

        ```python
        gui.loop()
        # things crash
        # things burn
        # things take over the world.
        ```
        &#34;&#34;&#34;

        inventory = False

        while True:
            event, values = self.window.read(timeout=c.ssi(&#39;async_timeout&#39;))
            if event != &#39;__TIMEOUT__&#39;:
                pass
            if event in (None, &#39;Quit&#39;):
                break

            if &#39;Change Expected Amount&#39; in event:
                cur_val = self.window[&#39;label_expected_amount&#39;].DisplayText
                layout = [[
                    sg.Input(&#34;{}&#34;.format(cur_val), focus=True, key=&#39;input_box&#39;)
                ], [sg.Button(&#39;Exit&#39;, bind_return_key=True)]]
                win2 = sg.Window(&#34;Edit Expected Amount&#34;, layout=layout)

                while True:
                    ev2, vals2 = win2.read()
                    if ev2 is None or ev2 == &#39;Exit&#39;:

                        self.window[&#39;label_expected_amount&#39;](str(
                            vals2[&#39;input_box&#39;]))
                        win2.close()
                        break

            if &#39;Run&#39; == values[&#39;main_menu&#39;]:
                self.log(&#39;Beginning simulation&#39;, &#39;info&#39;)
                simulator = Simulator(self)
                simulator.run()

            if &#39;button_inventory&#39; in event:
                self.log(&#34;Beginning inventory run&#34;, &#39;info&#39;)
                inventory = True
                self.set_window_title()

                expected_switches = self.read_expected()
                self.send_to_debug(f&#34;Expecting {expected_switches} switches..&#34;)

                port = str(c.lisc(&#39;port&#39;))
                baudrate = int(c.lisc(&#39;baudrate&#39;))
                with LISC(port=port, baudrate=baudrate, timeout=0) as lisc:
                    self.log(&#34;Spawning thread for inventory run&#34;, &#39;info&#39;)
                    thread = Process(target=lisc.do_inventory,
                                     args=(self.inventory_queue,
                                           expected_switches))
                    thread.start()

            if inventory:
                try:
                    # returns a deque object with information
                    msgs = self.inventory_queue.get_nowait()
                    if not isinstance(msgs, deque):
                        &#34;&#34;&#34;
                        This piece of code should never run, if it does it is a programmer induced bug
                        and not the users fault. msgs is in incorrect format, the entire program will
                        not work as intended. Instead of exiting the programming, simply stop the inventory
                        process and default back to normal GUI.
                        &#34;&#34;&#34;
                        inventory = False  # turn off inventory
                        errmsg = \
                        &#34;&#34;&#34;
                        Message from queue is not a ConnPackage, fatal error. Program will
                        not work as expected
                        &#34;&#34;&#34;
                        self.log(errmsg, &#39;error&#39;)

                    if len(msgs) &gt; 0:

                        info_type, mode, msg = msgs
                        if info_type == InfoType.KILL:
                            msg = &#34;Done with inventory process&#34;
                            self.send_mode(mode, msg)
                            inventory = False
                            self.log(msg, &#34;info&#34;)

                        if info_type == InfoType.SWITCH:

                            if mode == ConnMode.STATUS:
                                pos, addr, status = msg
                                self.send_mode(mode, status)

                            if mode == ConnMode.MAIN:
                                pos, addr = msg
                                self.update_anticipated(num=int(pos))
                                msg = &#34;--&gt; {}: [{}]&#34;.format(pos, addr)
                                self.send_mode(mode, msg)

                        if info_type == InfoType.OTHER:
                            self.send_mode(mode, msg)

                except Exception:
                    pass

        self.window.close()
        self.log(&#34;Main Gui loop closing&#34;, &#34;info&#34;)

    def read_expected(self):
        &#34;&#34;&#34;
        ```python
        input: None
        return: int
        ```
        Helper method that returns the number for anticipated switches
        from label. Attempts to convert to int, with some error checking.
        If it fails the conversion it will by default return `1`
        &#34;&#34;&#34;
        num = self.window[&#39;label_expected_amount&#39;].DisplayText
        try:
            num = int(num)
        except ValueError:
            num = 1

        return num

    def send_mode(self, mode, payload):
        &#34;&#34;&#34;
        ```
        input: ConnMode, PyObj
        return: None
        ```

        a proxy method that takes incoming data from 
        the queue object, and updates applicable elements
        within the main gui based on Connection Mode and InfoTypes
        found in packets.
        &#34;&#34;&#34;
        print(&#39;mode&#39;, mode)
        if mode == ConnMode.DEBUG:
            self.send_to_debug(msg=payload, clear=False)
        elif mode == ConnMode.MAIN:
            self.send_to_main(msg=payload, clear=False)

        elif mode == ConnMode.STATUS:
            status = Status(status)
            voltage = status.voltage
            temp = status.temp

            msg = &#34;{}V, {}C&#34;.format(voltage, temp)
            self.set_window_title(msg=msg)
        else:
            errmsg = \
                &#34;&#34;&#34;
                This block should never run. Input ConnMode from 
                thread supplies an invalid enum type, mode: {}
                &#34;&#34;&#34;.format(mode)
            self.log(errmsg, &#39;error&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pysrc.gui.SSI.inventory_queue"><code class="name">var <span class="ident">inventory_queue</span></code></dt>
<dd>
<section class="desc"><p>thread-safe <em>half-duplex</em> channel that is used when moving
entire inventory process on a seperate thread. This allows for communication
back to main thread.</p></section>
</dd>
<dt id="pysrc.gui.SSI.lo"><code class="name">var <span class="ident">lo</span></code></dt>
<dd>
<section class="desc"><p>variable to helper class that stores all layouts for PySimpleGui</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pysrc.gui.SSI.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>msg, status='info')</span>
</code></dt>
<dd>
<section class="desc"><pre><code class="python">input: str
return: None
</code></pre>
<p>Wrapper around log object to verify that output from GUI is going to gui.log</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def log(msg, status=&#39;info&#39;):
    &#34;&#34;&#34;
    ```python
    input: str
    return: None
    ```
    Wrapper around log object to verify that output from GUI is going to gui.log
    &#34;&#34;&#34;
    log.log(status)(msg, log.LogType.gui)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysrc.gui.SSI.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p><strong>main program loop, this is where ALL
the magic happens.</strong></p>
<pre><code class="python">gui.loop()
# things crash
# things burn
# things take over the world.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(self):
    &#34;&#34;&#34;
    **main program loop, this is where ALL 
    the magic happens.**

    ```python
    gui.loop()
    # things crash
    # things burn
    # things take over the world.
    ```
    &#34;&#34;&#34;

    inventory = False

    while True:
        event, values = self.window.read(timeout=c.ssi(&#39;async_timeout&#39;))
        if event != &#39;__TIMEOUT__&#39;:
            pass
        if event in (None, &#39;Quit&#39;):
            break

        if &#39;Change Expected Amount&#39; in event:
            cur_val = self.window[&#39;label_expected_amount&#39;].DisplayText
            layout = [[
                sg.Input(&#34;{}&#34;.format(cur_val), focus=True, key=&#39;input_box&#39;)
            ], [sg.Button(&#39;Exit&#39;, bind_return_key=True)]]
            win2 = sg.Window(&#34;Edit Expected Amount&#34;, layout=layout)

            while True:
                ev2, vals2 = win2.read()
                if ev2 is None or ev2 == &#39;Exit&#39;:

                    self.window[&#39;label_expected_amount&#39;](str(
                        vals2[&#39;input_box&#39;]))
                    win2.close()
                    break

        if &#39;Run&#39; == values[&#39;main_menu&#39;]:
            self.log(&#39;Beginning simulation&#39;, &#39;info&#39;)
            simulator = Simulator(self)
            simulator.run()

        if &#39;button_inventory&#39; in event:
            self.log(&#34;Beginning inventory run&#34;, &#39;info&#39;)
            inventory = True
            self.set_window_title()

            expected_switches = self.read_expected()
            self.send_to_debug(f&#34;Expecting {expected_switches} switches..&#34;)

            port = str(c.lisc(&#39;port&#39;))
            baudrate = int(c.lisc(&#39;baudrate&#39;))
            with LISC(port=port, baudrate=baudrate, timeout=0) as lisc:
                self.log(&#34;Spawning thread for inventory run&#34;, &#39;info&#39;)
                thread = Process(target=lisc.do_inventory,
                                 args=(self.inventory_queue,
                                       expected_switches))
                thread.start()

        if inventory:
            try:
                # returns a deque object with information
                msgs = self.inventory_queue.get_nowait()
                if not isinstance(msgs, deque):
                    &#34;&#34;&#34;
                    This piece of code should never run, if it does it is a programmer induced bug
                    and not the users fault. msgs is in incorrect format, the entire program will
                    not work as intended. Instead of exiting the programming, simply stop the inventory
                    process and default back to normal GUI.
                    &#34;&#34;&#34;
                    inventory = False  # turn off inventory
                    errmsg = \
                    &#34;&#34;&#34;
                    Message from queue is not a ConnPackage, fatal error. Program will
                    not work as expected
                    &#34;&#34;&#34;
                    self.log(errmsg, &#39;error&#39;)

                if len(msgs) &gt; 0:

                    info_type, mode, msg = msgs
                    if info_type == InfoType.KILL:
                        msg = &#34;Done with inventory process&#34;
                        self.send_mode(mode, msg)
                        inventory = False
                        self.log(msg, &#34;info&#34;)

                    if info_type == InfoType.SWITCH:

                        if mode == ConnMode.STATUS:
                            pos, addr, status = msg
                            self.send_mode(mode, status)

                        if mode == ConnMode.MAIN:
                            pos, addr = msg
                            self.update_anticipated(num=int(pos))
                            msg = &#34;--&gt; {}: [{}]&#34;.format(pos, addr)
                            self.send_mode(mode, msg)

                    if info_type == InfoType.OTHER:
                        self.send_mode(mode, msg)

            except Exception:
                pass

    self.window.close()
    self.log(&#34;Main Gui loop closing&#34;, &#34;info&#34;)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.read_expected"><code class="name flex">
<span>def <span class="ident">read_expected</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><pre><code class="python">input: None
return: int
</code></pre>
<p>Helper method that returns the number for anticipated switches
from label. Attempts to convert to int, with some error checking.
If it fails the conversion it will by default return <code>1</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_expected(self):
    &#34;&#34;&#34;
    ```python
    input: None
    return: int
    ```
    Helper method that returns the number for anticipated switches
    from label. Attempts to convert to int, with some error checking.
    If it fails the conversion it will by default return `1`
    &#34;&#34;&#34;
    num = self.window[&#39;label_expected_amount&#39;].DisplayText
    try:
        num = int(num)
    except ValueError:
        num = 1

    return num</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.send_mode"><code class="name flex">
<span>def <span class="ident">send_mode</span></span>(<span>self, mode, payload)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: ConnMode, PyObj
return: None
</code></pre>
<p>a proxy method that takes incoming data from
the queue object, and updates applicable elements
within the main gui based on Connection Mode and InfoTypes
found in packets.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_mode(self, mode, payload):
    &#34;&#34;&#34;
    ```
    input: ConnMode, PyObj
    return: None
    ```

    a proxy method that takes incoming data from 
    the queue object, and updates applicable elements
    within the main gui based on Connection Mode and InfoTypes
    found in packets.
    &#34;&#34;&#34;
    print(&#39;mode&#39;, mode)
    if mode == ConnMode.DEBUG:
        self.send_to_debug(msg=payload, clear=False)
    elif mode == ConnMode.MAIN:
        self.send_to_main(msg=payload, clear=False)

    elif mode == ConnMode.STATUS:
        status = Status(status)
        voltage = status.voltage
        temp = status.temp

        msg = &#34;{}V, {}C&#34;.format(voltage, temp)
        self.set_window_title(msg=msg)
    else:
        errmsg = \
            &#34;&#34;&#34;
            This block should never run. Input ConnMode from 
            thread supplies an invalid enum type, mode: {}
            &#34;&#34;&#34;.format(mode)
        self.log(errmsg, &#39;error&#39;)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.send_to_debug"><code class="name flex">
<span>def <span class="ident">send_to_debug</span></span>(<span>self, msg, clear=False)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: str, bool
return: None
</code></pre>
<p>helper method to update multiline that serves as debug output.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_debug(self, msg, clear=False):
    &#34;&#34;&#34;
    ```
    input: str, bool
    return: None
    ```
    helper method to update multiline that serves as debug output.

    &#34;&#34;&#34;
    widget = self.window[&#39;multiline_default_output&#39;]
    self.send_to_multiline(widget=widget, msg=msg, clear=clear)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.send_to_main"><code class="name flex">
<span>def <span class="ident">send_to_main</span></span>(<span>self, msg, clear=False)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: str, bool
return: None
</code></pre>
<p>helper method to update main multiline element in
GUI, where Switch information is posted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_main(self, msg, clear=False):
    &#34;&#34;&#34;
    ```
    input: str, bool
    return: None
    ```
    helper method to update main multiline element in 
    GUI, where Switch information is posted.
    &#34;&#34;&#34;
    widget = self.window[&#39;multiline_switch_canvas&#39;]
    self.send_to_multiline(widget=widget, msg=msg, clear=clear)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.send_to_multiline"><code class="name flex">
<span>def <span class="ident">send_to_multiline</span></span>(<span>self, widget, msg, clear=False)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: sg.Element, str, bool
return: None
</code></pre>
<p>helper method to update a tk multiline element</p>
<pre><code class="python">my_widget = window['label']
send_to_multiline(my_widget, msg=&quot;hello, world&quot;, clear=False)

print(my_widget.DisplayText) # &quot;hello, world&quot;
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_multiline(self, widget, msg, clear=False):
    &#34;&#34;&#34;
    ```
    input: sg.Element, str, bool
    return: None
    ```
    helper method to update a tk multiline element

    ```python
    my_widget = window[&#39;label&#39;]
    send_to_multiline(my_widget, msg=&#34;hello, world&#34;, clear=False)

    print(my_widget.DisplayText) # &#34;hello, world&#34;
    ```
    &#34;&#34;&#34;

    if clear:
        widget(msg)
    else:
        current = widget.get()
        new_string = current + str(msg)
        widget(new_string)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.set_window_title"><code class="name flex">
<span>def <span class="ident">set_window_title</span></span>(<span>self, msg='')</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: str
return: None
</code></pre>
<p>Set window title.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_window_title(self, msg=&#34;&#34;):
    &#34;&#34;&#34;
    ```
    input: str
    return: None
    ```
    Set window title.

    &#34;&#34;&#34;
    msg = &#34;SSI v{} {}&#34;.format(c.ssi(&#34;version&#34;), msg)
    self.window.TKroot.title(msg)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.update_anticipated"><code class="name flex">
<span>def <span class="ident">update_anticipated</span></span>(<span>self, num)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: str
return: None
</code></pre>
<p>helper method to update number of anticipated switches</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_anticipated(self, num):
    &#34;&#34;&#34;        
    ```
    input: str
    return: None
    ```
    helper method to update number of anticipated switches

    &#34;&#34;&#34;
    w = self.window[&#39;label_anticipated_amount&#39;]
    w(num)</code></pre>
</details>
</dd>
<dt id="pysrc.gui.SSI.write_element"><code class="name flex">
<span>def <span class="ident">write_element</span></span>(<span>self, window, key, msg, append=True)</span>
</code></dt>
<dd>
<section class="desc"><pre><code>input: sg.Window, str, str, bool
return: None
</code></pre>
<p>same functionality as send_to_multiline except you can
specifiy sg.Window object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_element(self, window, key, msg, append=True):
    &#34;&#34;&#34;
    ```
    input: sg.Window, str, str, bool
    return: None
    ```
    same functionality as send_to_multiline except you can 
    specifiy sg.Window object.

    &#34;&#34;&#34;

    ele = window.Element(key)
    try:
        ele.update(msg + &#39;\n&#39;, append=append)
    except Exception:
        ele.DisplayText = msg</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysrc" href="index.html">pysrc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pysrc.gui.SSI" href="#pysrc.gui.SSI">SSI</a></code></h4>
<ul class="two-column">
<li><code><a title="pysrc.gui.SSI.inventory_queue" href="#pysrc.gui.SSI.inventory_queue">inventory_queue</a></code></li>
<li><code><a title="pysrc.gui.SSI.lo" href="#pysrc.gui.SSI.lo">lo</a></code></li>
<li><code><a title="pysrc.gui.SSI.log" href="#pysrc.gui.SSI.log">log</a></code></li>
<li><code><a title="pysrc.gui.SSI.loop" href="#pysrc.gui.SSI.loop">loop</a></code></li>
<li><code><a title="pysrc.gui.SSI.read_expected" href="#pysrc.gui.SSI.read_expected">read_expected</a></code></li>
<li><code><a title="pysrc.gui.SSI.send_mode" href="#pysrc.gui.SSI.send_mode">send_mode</a></code></li>
<li><code><a title="pysrc.gui.SSI.send_to_debug" href="#pysrc.gui.SSI.send_to_debug">send_to_debug</a></code></li>
<li><code><a title="pysrc.gui.SSI.send_to_main" href="#pysrc.gui.SSI.send_to_main">send_to_main</a></code></li>
<li><code><a title="pysrc.gui.SSI.send_to_multiline" href="#pysrc.gui.SSI.send_to_multiline">send_to_multiline</a></code></li>
<li><code><a title="pysrc.gui.SSI.set_window_title" href="#pysrc.gui.SSI.set_window_title">set_window_title</a></code></li>
<li><code><a title="pysrc.gui.SSI.update_anticipated" href="#pysrc.gui.SSI.update_anticipated">update_anticipated</a></code></li>
<li><code><a title="pysrc.gui.SSI.write_element" href="#pysrc.gui.SSI.write_element">write_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>